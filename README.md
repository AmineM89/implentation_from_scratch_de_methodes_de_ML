Dans ce projet, j'ai entrepris l'excitant défi de coder de zéro différentes méthodes d'apprentissage automatique, spécifiquement axées sur la classification. L'objectif était de comprendre en profondeur le fonctionnement de ces techniques et de les implémenter sans recourir à des bibliothèques externes telles que Scikit-Learn ou TensorFlow.

Pour ce faire, nous avons choisi d'utiliser trois datasets présentant des niveaux de difficulté variés : facile, moyen et difficile. Chacun de ces jeux de données contient uniquement deux caractéristiques (2D), ce qui permet une visualisation plus simple des données et une meilleure compréhension du fonctionnement des méthodes.

J'ai couvert un large éventail de méthodes de classification, notamment :

### Classifieurs par Distance:
J'ai implémenté la classification basée sur des distances, en utilisant les métriques euclidienne et Mahalanobis. Ces méthodes sont essentielles pour la classification basée sur la proximité des points de données.

### k Plus Proches Voisins (k-NN):
J'ai développé l'algorithme des k plus proches voisins, une méthode populaire qui classe les données en fonction des voisins les plus proches dans l'espace des caractéristiques.

### Fenêtre de Parzen:
J'ai créé une implémentation de la méthode de la fenêtre de Parzen, qui est une technique de classification basée sur l'estimation de densité.

### Séparation Linéaire:
J'ai travaillé sur la séparation linéaire, une technique qui vise à trouver un hyperplan de séparation pour les données.

### SVM avec Kernel:
J'ai mis en œuvre des Machines à Vecteurs de Support (SVM) avec différentes fonctions noyau, telles que le noyau linéaire, le noyau polynomial, et le noyau gaussien (RBF).

Dans le cadre de ce projet, j'ai également effectué le paramétrage de ces méthodes en utilisant des techniques de validation croisée pour optimiser leurs performances.

## Conclusion:
Ce projet m'a permis de plonger profondément dans les mathématiques, les concepts et les détails de chaque méthode, tout en acquérant une compréhension pratique de leur fonctionnement. J'ai également eu l'occasion de comparer les performances de ces implémentations avec des outils d'apprentissage automatique standard.

L'objectif de ce Jupyter Notebook est de documenter ces implémentations, d'expliquer le code et de fournir des exemples d'utilisation pour chaque méthode. J'espère que ce projet pourra servir de ressource pédagogique pour ceux qui cherchent à approfondir leur compréhension des méthodes d'apprentissage automatique.

N'hésitez pas à explorer chaque section pour en savoir plus sur les détails de chaque méthode et pour voir comment elles ont été mises en œuvre.
